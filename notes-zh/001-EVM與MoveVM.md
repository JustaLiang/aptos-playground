# EVM 與 Move VM 的差別

### 前言

最近 Move 語言掀起一波討論潮，究竟 Move 是不是個更好更安全的語言，還是又是一個過譽的以太系列殺手。我們都知道語言的特性跟 VM 的設計有很大關係，所以今天就來聊聊 EVM 與 Move VM 的設計差異，順便會帶到一點 Solana Runtime 的特性。然後會特別就資產的處理方式著重進行討論，分別用 Ethereum 上的 ERC20、Solana 上的 SPL-Token 和 Aptos 上的 Coin 為例讓大家感受 VM 和語言的特性。

### EVM

EVM 我想大家都耳熟能詳，因為現在大部分的鏈都是 EVM 相容的。EVM 的儲存在設計上很單純，智能合約基本上兼具了資料庫和後端邏輯。除了EOA（有私鑰的地址）儲存原生幣的持有數量之外，其他資產的資料都是存在該資產對應的智能合約中。

舉例來說，USDC 的合約裡會紀錄某個地址有多少數量（資料庫），誰有能力鑄造以及鑄造方式的介面（後端）。 Alice 轉給 Bob 100 顆 USDC，就把 Alice 地址對應的數量減 100，然後 Bob 的加 100。

#### 優點

對於前後端來說非常友善，鏈上定義好合約的資料儲存和運作方式之後，前端只要像打 API 一樣跟合約互動，剩下就是看 EVM 秀操作。

合約之間的互動也很容易，只要知道該合約的介面和地址，就可以透過合約操作合約。只能說 EVM 和 Solidity 能有如此規模的生態，對開發者友善是其中一個很大的原因。

#### 缺點

資料庫和後端邏輯綁定雖然很直觀，但也有壞處。你發一個 ERC20 我發一個 ERC20，類似甚至是一模一樣的邏輯在鏈上就存在了兩份。雖然 EVM 有 delegateCall 的用法，也有人一直在倡導用 Diamond 合約的寫法，但畢竟未普及。至今已經有多少 ERC20 和 ERC721 的邏輯在上面重複存在，想想都後怕。

再來，因為對合約操作不需要處理資料儲存問題，所以 EVM 在執行之前並不知道會改動到鏈上的哪些資料，只有執行了才知道，所以並不能做到平行化處理，否則會有數據競爭的問題（data race），也就是說有兩個交易同時要改動一個資料的時候會導致一些怪異的結果。這就是為什麼以太的交易是必須先經過排序的並逐一結算的，至於用 gas price 作為排序先後的認定所造成的鏈費高漲的情況，我也不再贅述，想想又後怕了。

最後是安全性問題。你真的確定手上的幣和 NFT 是安全的嗎？你看過合約內容嗎？你會覺得阿就是 Openzeppelin 的 ERC20 和 ERC721 協議啊，只要實作協議就確保了正確的轉移和授權的方式了不是嗎？我只能說，還真的不是。事實上 ERC20 和 ERC721 只定義了介面，並沒有嚴格規定邏輯，所以你可以實作 ERC20 但是改成轉錢給別人的時候別人的資產會減半也是沒問題的。而且很簡單，一個 override 就搞定了。雖然這個彈性在某些方面滿有趣的，可以瞎搞出一些好玩的幣，但是作為資產就不好笑了。你手上的是資產還是遊戲點數，純看合約有沒有嚴格執行作為資產應有的行為。

### Solana Runtime

接下來聊聊 Solana，作為 FTX 的親兒子而言，他的 runtime 設計確實有厲害的地方。主要是他把邏輯和資料儲存分開，分的最開的那種。Program 是沒有狀態的，純粹的邏輯。像水管一樣，資料流進去再流到其他地方之後，水管還是水管，沒有任何改變。而 Account 就是只存放資料，任由他所屬的 Program 宰割。

所以 Solana 這台世界電腦看起來就像是一堆有輸入輸出的函數以及記憶體所構成，送交易的時候要把用到哪些函數和存取哪塊記憶體告訴 runtime，如果不存在的 Account 要把他配置出來。因為 Program 可以重複使用的關係，所以其實大部分時候是不需要部署 Program 的，鏈上那些夠你用了，只要弄好 Account 讓 Program 去存取就好了。

而 Solana 上的資產主要是 SPL-Token，SPL 是 Solana Program Library 的意思，由 Solana 團隊開發並部署了一系列的 Program，就像你寫 C 或 rust 可以直接使用 std:: 開頭的函數。而其中有一個 Program 叫做 Token Program，由這個 Program 所規範的資產就叫做 SPL-Token。在 Solana 上發幣很單純，在 Token Program 下開一個 Mint Account 紀錄幣的名子或要發幾顆之類的。然後要持有該幣的人也只要開一個 Token Account，裡面記錄要收哪個幣就行。Alice 要轉 100 顆給 Bob 就告訴 runtime 我要調用 Token Program 然後把該幣的 Mint Account 和彼此的 Token Account 給他，確認沒問題就在 Alice 的 Token Account 裡數量減 100 而 Bob 的加 100。

#### 優點

Runtime 在處理交易前就已經知道所有會用到的 Account（因為你必須告訴他），所以如果兩個交易沒有存取同一個 Account，是完全可以平行處理的。這也是 Solana 的 TPS 可以這麼高的原因之一。

再來，邏輯不需要重複寫，可以組合 SPL 裡的那些 Programs 來做出很酷炫又複雜的事情。

最後，因為資產的邏輯是共用的，所以只要你確認你的幣是 SPL-Token，就能確定他有基本資產該有的運作模式。不會憑空出現或消失。

#### 缺點

雖然看我講起來好像很簡單，但事實上 Solana 的開發並不容易。光是要把這個交易所有需要用到的 Account 全部搜集到就夠你忙的了，如果開發 Program 要用到其他的 Program 還需要 CPI 或 PDA。不說了，懂的都懂。但有富爸爸支持，重賞下必有勇夫，牛逼的工程師還是夠用的，所以 Solana 的生態目前也是有聲有色。

再來，SPL-Token 還有一個管理上的問題。以太上你可以用一個地址存放多個幣種，因為只是把地址有幾顆記錄在各個的 ERC20 合約裡。但 SPL-Token 的架構下，一個幣種就要開一個 Account 去存放。如果你持有十個幣就有十個帳號和私鑰要管理，就像出門要攜帶十把鑰匙一樣，直接吐血。不過還好這已經有了解決方式，詳細可以搜尋 ATA（Associated Token Account），簡單來說就是把各個 Token Account 跟你的主要帳號關聯起來的作法，但這畢竟還是需要一些額外的運算和工程師的智商。

### Move VM

本文章的主角終於登場。Solana 的 SPL-Token 看起來是個問題不大的設計，EVM 的 ERC20 看起來雖然問題不少但畢竟行之有年，各種 DeFi 大家也是玩得挺嗨。究竟 Move 和 Move VM 能不能突破重圍，成為最適合管理鏈上資產的語言與架構。我說的不準，不如我們從 Solana 官網上的某個提案來體會一下

https://docs.solana.com/proposals/embedding-move

簡單來說，裡面按照慣例就不能平行化的方面把 EVM 體系貶了一頓，然後提到 Move 語言一樣有對 Account 進行可平行化處理，後面甚至承認 Move VM 在模組之間互相調用的處理做得更為優秀。提案的最後定義了該提案最終想要達成的三件事：

- Move 部分的模組互動不需要 runtime 檢查
- Move 的模組能夠調用 Solana 現有的 Programs
- Runtime 的平行化機制要能同時作用在 Move 和非 Move 的交易上

也就是說，Solana 想要整合 Move 到他的 runtime 裡，並支援用 Move 語言開發並部署模組。我理解各個語言和架構都有其支持者，但能夠讓對手稱讚，是一種本事。甚至讓對手打不贏就加入，那就是屌炸天。

賣夠關子了，接下來我們 move 到正題

#### Move 與 Rust 的關係

Move 很大程度地受到 Rust 的啟發，繼承了許多 Rust 優秀的特性，同時又針對區塊鏈的需求去做特化。我原本對於這種特化語言不是特別舒服，像 Solana 純用 Rust 開發多好，為什麼要製造這種類似又有一點不樣的語言去造成開發者的困擾（例如 fn 變成 fun 到底是 fun 在哪...）。但事實上這樣做有他的好處，因為區塊鏈節點的運行並不像是一般的電腦跑程式。人人都可以把程式或合約部署上鏈來給大家使用，所以必須有個管理者規範他們。用 Rust 這種泛用型語言開發，就需要額外的程式去管理，這就是 Solana Runtime 的作用。但是協調這些 Programs 會花費額外的計算，而且會要求開發者去注意 runtime 的機制和規範。

另一方面，Move 就像 Solidity 一樣，有對應的 VM，有對應的一組 OpCode。所以基本上編譯完部署上鏈之後，程式之間可以無痛互動，不需要額外的協調程式，因為與別的模組良好互動的特性已經在編譯的時候內化到他們基因中。按照 Solana 官網上的說法，Solana 額外的程式管理就像是 Python 這種動態語言的處理方式，而 Move 更像是 Java 這種靜態語言，用 domain-specific 的方式自我約束。

而有別於 Solidity 和 EVM，Move 又支援可平行化，因為資料也是主要儲存在 Account 之下。可以說 Move VM 結合了 EVM 和 Solana Runtime 的優點，而且在 account-based 的基礎上又省去了 ATA 這種有點畸形的帳號管理方式。接下來就詳細講解一下 Move 為何可以這麼猛。

#### 泛型（Generic）

Trait 和 Generic 是 Rust 非常強大的特性，簡單來說，你可以為任何有某個特徵的類型實作該類型的操作，而這個操作可以套用到任何擁有這個特徵的類型，不管是前人定義的類型，或是未來將要定義的類型。也就是說，你可以幫任何可以定義長寬的類型實作計算面積的操作，未來別人定義了某個有長寬的資料類型，也可以使用你定義的面積運算。也就是你可以寫出古往今來放諸四海皆準的通用性邏輯運算，而如果把這樣的特性運用在資產的定義上格外適合。Move 可以圍繞 Coin 這個類型去定義貨幣所需要的操作。

如此一來，有點像 Solana 的 SPL-Token 的感覺，直接為 Token 或 Coin 制定了一個邏輯標準，確保了資產的安全性。用戶可以輕易的查出自己的資產是不是屬於標準規範下的，以 Aptos 為例，只要查看你持有的資產是0x1::coin::CoinStore<?> 這樣的類型，就可以知道該資產是由標準模組 0x1::coin 所規範。

至於上面這串是什麼意思呢？這就要談到 Resources

#### 資源（Resources）

Move 認為存在帳號之下的數據是神聖不可侵犯的，並給他一個炫砲的名子，叫 Resources。而每個 Resources 都會有一個 Key，像剛剛的例子裡 0x1::coin::CoinStore<T> 就是一個 Key，這個 Key 在同個帳號之下只會存在一個。而利用泛型可以把這這樣的類型推廣到各個幣種，<T> 可以是 <USD> <JPY> 等等，用這個方式讓你的帳號之下可以存在多種幣，但這些幣又都遵守同個規範，因為 Move VM 規定，只有 0x1::coin 這個模組能夠操作 0x1::coin::CoinStore<T>。

這串 Key 就包含了完整的規範資訊。 0x1 就是標準模組存放的 Account 地址，而 coin 就是其中制定貨幣規範的模組，CoinStore 則是這個模組裡定義的類型，儲存你有多少數量的貨幣。而只有 0x1::coin 這個模組能夠操其下定義的類型。下面用兩張圖來說明 Solidity 和 Move 儲存資料的差別。

<img src="https://miro.medium.com/max/4800/0*QxtLsxCiZsDrAXVB.png" alt="solidity state"/>

<img src="https://miro.medium.com/max/4800/0*RCtumiMIxqKnIm7I.png" alt="move state"/>

可以看用有別於 Solidity 是將合約地址擺在檢索的第一層，而是以帳號地址為首，這樣的設計可以幫助平行化。乍看之下跟 Solana 比較像，但 Solana 其實並沒有這樣嚴謹的樹狀結構，各個帳號地址其實就像散落在電腦裡的記憶體位址一樣，基本上是找不到任何關聯的，要靠 runtime 和其他程式組織起來。而 Move 裡這種 Key 和 Resources 的結構，做到像 Solana ATA 那樣的效果，而且是內建的，不需要調用 ATA Program。

### 結論

Move 有 Solidity 這種特化語言的優勢，在模組互動方面簡單純粹，而又吸收了 Solana 這種 account-based 的平行化優勢。就用下面這張圖表做個總結。

下一篇會深入來講解 Aptos 的標準模組，順便學習一個 Move 的模組會長什麼樣子。
